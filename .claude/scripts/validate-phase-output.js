#!/usr/bin/env node
/**
 * validate-phase-output.js
 * Validates that expected artifacts exist after a workflow phase completes
 *
 * Usage:
 *   node .claude/scripts/validate-phase-output.js --phase <PHASE> [--epic <N>] [--story <M>]
 *
 * Workflow Structure (3 Stages):
 *   Stage 1: DESIGN (once) → SCOPE (define epics only)
 *   Stage 2: Per-Epic: STORIES (define stories for current epic)
 *   Stage 3: Per-Story: REALIGN → SPECIFY → IMPLEMENT → REVIEW → VERIFY
 *
 * Phases and their expected artifacts:
 *   DESIGN: wireframes in generated-docs/wireframes/
 *   SCOPE: _feature-overview.md with epics defined
 *   STORIES: story files in epic dir with acceptance criteria
 *   SPECIFY: test files for current story
 *   IMPLEMENT: source files that tests import
 *   REVIEW: review marker or findings file
 *   VERIFY: quality-gate-status.json
 *
 * Exit codes:
 *   0 - All expected artifacts found
 *   1 - Some non-critical artifacts missing (warnings)
 *   2 - Critical artifacts missing (phase not complete)
 */

const fs = require('fs');
const path = require('path');

// =============================================================================
// HELPERS
// =============================================================================

function findFiles(dir, pattern) {
  if (!fs.existsSync(dir)) return [];

  const regex = new RegExp('^' + pattern.replace(/\*/g, '.*').replace(/\?/g, '.') + '$');

  try {
    return fs.readdirSync(dir)
      .filter(file => regex.test(file))
      .map(file => path.join(dir, file));
  } catch {
    return [];
  }
}

function findFilesRecursive(dir, pattern) {
  if (!fs.existsSync(dir)) return [];

  const regex = new RegExp('^' + pattern.replace(/\*/g, '.*').replace(/\?/g, '.') + '$');
  const results = [];

  function walk(currentDir) {
    try {
      const entries = fs.readdirSync(currentDir, { withFileTypes: true });
      for (const entry of entries) {
        const fullPath = path.join(currentDir, entry.name);
        if (entry.isDirectory()) {
          walk(fullPath);
        } else if (regex.test(entry.name)) {
          results.push(fullPath);
        }
      }
    } catch {
      // Ignore permission errors
    }
  }

  walk(dir);
  return results;
}

function fileHasContent(filePath, minBytes = 10) {
  try {
    const stats = fs.statSync(filePath);
    return stats.size >= minBytes;
  } catch {
    return false;
  }
}

function extractImportsFromTestFile(testFilePath) {
  // Extract import paths from a test file to verify implementation exists
  try {
    const content = fs.readFileSync(testFilePath, 'utf-8');
    const imports = [];

    // Match import statements with @/ paths
    const importRegex = /import\s+.*from\s+['"](@\/[^'"]+)['"]/g;
    let match;
    while ((match = importRegex.exec(content)) !== null) {
      imports.push(match[1]);
    }

    return imports;
  } catch {
    return [];
  }
}

function resolveAliasPath(aliasPath) {
  // Convert @/ path to actual file path
  if (aliasPath.startsWith('@/')) {
    const relativePath = aliasPath.replace('@/', 'web/src/');
    // Try with common extensions
    const extensions = ['', '.ts', '.tsx', '.js', '.jsx', '/index.ts', '/index.tsx'];
    for (const ext of extensions) {
      const fullPath = relativePath + ext;
      if (fs.existsSync(fullPath)) {
        return fullPath;
      }
    }
  }
  return null;
}

// =============================================================================
// PHASE VALIDATORS
// =============================================================================

function validateDesign() {
  const result = {
    status: 'valid',
    phase: 'DESIGN',
    expected: ['wireframes in generated-docs/wireframes/'],
    found: [],
    missing: [],
    warnings: []
  };

  const wireframeDir = 'generated-docs/wireframes';

  if (!fs.existsSync(wireframeDir)) {
    result.status = 'invalid';
    result.missing.push('generated-docs/wireframes/ directory');
    return result;
  }

  const wireframes = findFiles(wireframeDir, '*.md');
  const overviewFile = path.join(wireframeDir, '_overview.md');

  if (wireframes.length === 0) {
    result.status = 'invalid';
    result.missing.push('wireframe markdown files');
  } else {
    result.found.push(`${wireframes.length} wireframe file(s)`);
  }

  if (!fs.existsSync(overviewFile)) {
    result.warnings.push('_overview.md not found (optional but recommended)');
  } else {
    result.found.push('_overview.md');
  }

  return result;
}

function validateScope() {
  const result = {
    status: 'valid',
    phase: 'SCOPE',
    expected: ['_feature-overview.md with epics defined'],
    found: [],
    missing: [],
    warnings: []
  };

  const storiesDir = 'generated-docs/stories';
  const featureOverview = path.join(storiesDir, '_feature-overview.md');

  // Check feature overview
  if (!fs.existsSync(featureOverview)) {
    result.status = 'invalid';
    result.missing.push('generated-docs/stories/_feature-overview.md');
    return result;
  }

  if (!fileHasContent(featureOverview, 50)) {
    result.status = 'invalid';
    result.missing.push('_feature-overview.md has no content');
    return result;
  }

  // Verify feature overview contains epic definitions
  try {
    const content = fs.readFileSync(featureOverview, 'utf-8');
    if (!content.includes('Epic') && !content.includes('epic')) {
      result.status = 'invalid';
      result.missing.push('_feature-overview.md does not contain epic definitions');
    } else {
      result.found.push('_feature-overview.md with epic definitions');
    }
  } catch {
    result.status = 'invalid';
    result.missing.push('Could not read _feature-overview.md');
  }

  return result;
}

function validateStories(epicNum) {
  const result = {
    status: 'valid',
    phase: 'STORIES',
    epic: epicNum,
    expected: ['epic directory with story files and acceptance criteria'],
    found: [],
    missing: [],
    warnings: []
  };

  if (!epicNum) {
    result.status = 'invalid';
    result.missing.push('Epic number required for STORIES validation');
    return result;
  }

  const storiesDir = 'generated-docs/stories';

  // Check stories directory exists
  if (!fs.existsSync(storiesDir)) {
    result.status = 'invalid';
    result.missing.push('generated-docs/stories/ directory');
    return result;
  }

  // Find epic directory
  const epicDirs = fs.readdirSync(storiesDir)
    .filter(d => d.startsWith(`epic-${epicNum}`))
    .map(d => path.join(storiesDir, d))
    .filter(d => fs.statSync(d).isDirectory());

  if (epicDirs.length === 0) {
    result.status = 'invalid';
    result.missing.push(`epic-${epicNum}-* directory`);
    return result;
  }

  const epicDir = epicDirs[0];
  const epicName = path.basename(epicDir);

  // Check epic overview
  const epicOverview = path.join(epicDir, '_epic-overview.md');
  if (!fs.existsSync(epicOverview)) {
    result.warnings.push(`${epicName}/_epic-overview.md missing`);
  } else {
    result.found.push(`${epicName}/_epic-overview.md`);
  }

  // Check story files
  const storyFiles = findFiles(epicDir, 'story-*.md');

  if (storyFiles.length === 0) {
    result.status = 'invalid';
    result.missing.push(`${epicName}/story-*.md files`);
    return result;
  }

  result.found.push(`${epicName}: ${storyFiles.length} story file(s)`);

  // Validate story files have acceptance criteria
  for (const storyFile of storyFiles) {
    try {
      const content = fs.readFileSync(storyFile, 'utf-8');
      if (!content.includes('## Acceptance Criteria') && !content.includes('### ')) {
        result.warnings.push(`${path.basename(storyFile)} may be missing acceptance criteria`);
      }
    } catch {
      // Skip unreadable files
    }
  }

  return result;
}

function validateSpecify(epicNum, storyNum) {
  const result = {
    status: 'valid',
    phase: 'SPECIFY',
    epic: epicNum,
    story: storyNum,
    expected: storyNum
      ? [`test files for epic-${epicNum} story-${storyNum}`]
      : [`test files for epic-${epicNum}`],
    found: [],
    missing: [],
    warnings: []
  };

  if (!epicNum) {
    result.status = 'invalid';
    result.missing.push('Epic number required for SPECIFY validation');
    return result;
  }

  // Look for test files in integration directory
  const testDir = 'web/src/__tests__/integration';

  if (!fs.existsSync(testDir)) {
    result.status = 'invalid';
    result.missing.push('web/src/__tests__/integration/ directory');
    return result;
  }

  // Find test files for this epic (and optionally story)
  const testFiles = fs.readdirSync(testDir)
    .filter(f => {
      const matchesEpic = f.includes(`epic-${epicNum}`);
      const matchesStory = storyNum ? f.includes(`story-${storyNum}`) : true;
      const isTestFile = f.endsWith('.test.tsx') || f.endsWith('.test.ts');
      return matchesEpic && matchesStory && isTestFile;
    });

  if (testFiles.length === 0) {
    result.status = 'invalid';
    const pattern = storyNum
      ? `epic-${epicNum}-story-${storyNum}-*.test.tsx`
      : `epic-${epicNum}-*.test.tsx`;
    result.missing.push(`test files matching ${pattern}`);
    return result;
  }

  const desc = storyNum
    ? `${testFiles.length} test file(s) for epic-${epicNum} story-${storyNum}`
    : `${testFiles.length} test file(s) for epic-${epicNum}`;
  result.found.push(desc);

  // Validate test files have actual test content
  for (const testFile of testFiles) {
    const fullPath = path.join(testDir, testFile);
    try {
      const content = fs.readFileSync(fullPath, 'utf-8');

      if (!content.includes('describe(') && !content.includes('it(') && !content.includes('test(')) {
        result.warnings.push(`${testFile} has no test blocks`);
      }

      if (content.includes('.skip(') || content.includes('.todo(')) {
        result.warnings.push(`${testFile} contains skipped or todo tests`);
      }
    } catch {
      result.warnings.push(`Could not read ${testFile}`);
    }
  }

  return result;
}

function validateImplement(epicNum, storyNum) {
  const result = {
    status: 'valid',
    phase: 'IMPLEMENT',
    epic: epicNum,
    story: storyNum,
    expected: ['implementation files referenced by tests'],
    found: [],
    missing: [],
    warnings: []
  };

  if (!epicNum) {
    result.status = 'invalid';
    result.missing.push('Epic number required for IMPLEMENT validation');
    return result;
  }

  // Find test files for this epic (and optionally story)
  const testDir = 'web/src/__tests__/integration';

  if (!fs.existsSync(testDir)) {
    result.warnings.push('No integration test directory found');
    return result;
  }

  const testFiles = fs.readdirSync(testDir)
    .filter(f => {
      const matchesEpic = f.includes(`epic-${epicNum}`);
      const matchesStory = storyNum ? f.includes(`story-${storyNum}`) : true;
      const isTestFile = f.endsWith('.test.tsx') || f.endsWith('.test.ts');
      return matchesEpic && matchesStory && isTestFile;
    })
    .map(f => path.join(testDir, f));

  if (testFiles.length === 0) {
    const desc = storyNum ? `epic-${epicNum} story-${storyNum}` : `epic-${epicNum}`;
    result.warnings.push(`No test files found for ${desc}`);
    return result;
  }

  // Extract imports from test files and verify they exist
  const allImports = new Set();
  for (const testFile of testFiles) {
    const imports = extractImportsFromTestFile(testFile);
    imports.forEach(i => allImports.add(i));
  }

  let foundCount = 0;
  let missingCount = 0;

  for (const importPath of allImports) {
    // Skip test utilities and mocks
    if (importPath.includes('__tests__') || importPath.includes('mock') || importPath.includes('test-utils')) {
      continue;
    }

    const resolved = resolveAliasPath(importPath);
    if (resolved) {
      foundCount++;
      result.found.push(importPath);
    } else {
      missingCount++;
      result.missing.push(`${importPath} (referenced in tests but not found)`);
    }
  }

  if (missingCount > 0 && foundCount === 0) {
    result.status = 'invalid';
  } else if (missingCount > 0) {
    result.status = 'partial';
  }

  return result;
}

function validateReview(epicNum, storyNum) {
  const result = {
    status: 'valid',
    phase: 'REVIEW',
    epic: epicNum,
    story: storyNum,
    expected: ['review findings or marker'],
    found: [],
    missing: [],
    warnings: []
  };

  // Check for review findings JSON
  const findingsPath = '.claude/context/review-findings.json';
  if (fs.existsSync(findingsPath)) {
    try {
      const content = fs.readFileSync(findingsPath, 'utf-8');
      const findings = JSON.parse(content);
      if (findings.recommendation) {
        result.found.push('review-findings.json with recommendation');
        return result;
      }
    } catch {
      result.warnings.push('review-findings.json exists but is invalid');
    }
  }

  // Check for story-specific review marker
  if (epicNum && storyNum) {
    const reviewMarker = `generated-docs/reviews/epic-${epicNum}-story-${storyNum}-review.md`;
    if (fs.existsSync(reviewMarker)) {
      result.found.push(`epic-${epicNum}-story-${storyNum}-review.md`);
      return result;
    }
  }

  // Check for epic-specific review marker
  if (epicNum) {
    const reviewMarker = `generated-docs/reviews/epic-${epicNum}-review.md`;
    if (fs.existsSync(reviewMarker)) {
      result.found.push(`epic-${epicNum}-review.md`);
      return result;
    }
  }

  // Check workflow state for review status
  const statePath = '.claude/context/workflow-state.json';
  if (fs.existsSync(statePath)) {
    try {
      const state = JSON.parse(fs.readFileSync(statePath, 'utf-8'));
      if (state.epics && epicNum && state.epics[epicNum]) {
        const epicState = state.epics[epicNum];

        // Check story-level phase if storyNum provided
        if (storyNum && epicState.stories && epicState.stories[storyNum]) {
          const storyState = epicState.stories[storyNum];
          if (['VERIFY', 'COMPLETE'].includes(storyState.phase)) {
            result.found.push('workflow state indicates story review completed');
            return result;
          }
        }

        // Check epic-level phase
        if (['VERIFY', 'COMPLETE'].includes(epicState.phase)) {
          result.found.push('workflow state indicates review completed');
          return result;
        }
      }
    } catch {
      // Invalid state file
    }
  }

  result.status = 'invalid';
  result.missing.push('No review completion indicator found');
  return result;
}

function validateVerify(epicNum, storyNum) {
  const result = {
    status: 'valid',
    phase: 'VERIFY',
    epic: epicNum,
    story: storyNum,
    expected: ['quality-gate-status.json'],
    found: [],
    missing: [],
    warnings: []
  };

  const statusPath = '.claude/context/quality-gate-status.json';

  if (!fs.existsSync(statusPath)) {
    result.status = 'invalid';
    result.missing.push('.claude/context/quality-gate-status.json');
    return result;
  }

  try {
    const content = fs.readFileSync(statusPath, 'utf-8');
    const status = JSON.parse(content);

    if (!status.overallStatus) {
      result.warnings.push('quality-gate-status.json missing overallStatus');
    } else if (status.overallStatus === 'pass') {
      result.found.push('quality-gate-status.json with passing status');
    } else {
      result.warnings.push(`quality-gate-status.json shows ${status.overallStatus} status`);
    }

    // Check that gates are present
    if (!status.gates) {
      result.warnings.push('quality-gate-status.json missing gates object');
    } else {
      const gateCount = Object.keys(status.gates).length;
      result.found.push(`${gateCount} quality gates recorded`);
    }

    // If story-level validation, check that status includes story info
    if (storyNum && status.story !== storyNum) {
      result.warnings.push(`quality-gate-status.json may not be for story ${storyNum}`);
    }
  } catch (e) {
    result.status = 'invalid';
    result.missing.push('quality-gate-status.json is invalid JSON');
  }

  return result;
}

// =============================================================================
// MAIN
// =============================================================================

function main() {
  const args = process.argv.slice(2);

  if (args.length === 0 || args.includes('--help') || args.includes('-h')) {
    console.log(`
Usage: node .claude/scripts/validate-phase-output.js --phase <PHASE> [--epic <N>] [--story <M>]

Workflow Structure (3 Stages):
  Stage 1: DESIGN (once) → SCOPE (define epics only)
  Stage 2: Per-Epic: STORIES (define stories for current epic)
  Stage 3: Per-Story: REALIGN → SPECIFY → IMPLEMENT → REVIEW → VERIFY

Phases: DESIGN, SCOPE, STORIES, SPECIFY, IMPLEMENT, REVIEW, VERIFY

Options:
  --phase <PHASE>  Phase to validate (required)
  --epic <N>       Epic number (required for STORIES, SPECIFY, IMPLEMENT, REVIEW, VERIFY)
  --story <M>      Story number (optional, for per-story validation)

Exit codes:
  0 - All expected artifacts found
  1 - Some non-critical artifacts missing (warnings)
  2 - Critical artifacts missing (phase not complete)
`);
    process.exit(0);
  }

  let phase = null;
  let epicNum = null;
  let storyNum = null;

  for (let i = 0; i < args.length; i++) {
    if (args[i] === '--phase' && args[i + 1]) {
      phase = args[i + 1].toUpperCase();
      i++;
    } else if (args[i] === '--epic' && args[i + 1]) {
      epicNum = parseInt(args[i + 1]);
      i++;
    } else if (args[i] === '--story' && args[i + 1]) {
      storyNum = parseInt(args[i + 1]);
      i++;
    }
  }

  if (!phase) {
    console.log(JSON.stringify({
      status: 'error',
      message: 'Missing required --phase argument'
    }, null, 2));
    process.exit(2);
  }

  const validators = {
    'DESIGN': () => validateDesign(),
    'SCOPE': () => validateScope(),
    'STORIES': () => validateStories(epicNum),
    'SPECIFY': () => validateSpecify(epicNum, storyNum),
    'IMPLEMENT': () => validateImplement(epicNum, storyNum),
    'REVIEW': () => validateReview(epicNum, storyNum),
    'VERIFY': () => validateVerify(epicNum, storyNum)
  };

  if (!validators[phase]) {
    console.log(JSON.stringify({
      status: 'error',
      message: `Unknown phase: ${phase}. Valid phases: ${Object.keys(validators).join(', ')}`
    }, null, 2));
    process.exit(2);
  }

  const result = validators[phase]();

  // Add summary message
  if (result.status === 'valid') {
    result.message = `All expected artifacts found for ${phase} phase`;
  } else if (result.status === 'partial') {
    result.message = `Some artifacts found for ${phase} phase, but some are missing`;
  } else {
    result.message = `${phase} phase validation failed - critical artifacts missing`;
  }

  console.log(JSON.stringify(result, null, 2));

  // Set exit code based on status
  if (result.status === 'invalid') {
    process.exit(2);
  } else if (result.status === 'partial' || result.warnings.length > 0) {
    process.exit(1);
  } else {
    process.exit(0);
  }
}

main();
